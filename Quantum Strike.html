<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>CliJo - Quantum Strike</title>
<link rel="icon" href="logo.png" type="image/png">
<style>
body { margin:0; overflow:hidden; background:black; touch-action:none; }
canvas { display:block; }

/* HUD */
#scoreboard, #levelDisplay, #healthDisplay {
  position:absolute; color:cyan; font:20px Orbitron, Arial; top:10px; text-shadow:0 0 6px cyan;
}
#levelDisplay { left:10px; }
#scoreboard { right:10px; }
#healthDisplay { left:10px; top:40px; color:rgb(255,80,80); text-shadow:0 0 6px red; }

/* Back to Menu */
#menuButton {
  position:absolute; top:70px; left:10px; font-size:18px; padding:5px 10px;
  background:rgba(255,0,0,0.6); color:white; border:none; border-radius:5px;
  box-shadow:0 0 10px red;
}

/* Defeat Overlay */
#defeatOverlay {
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.9);
  display:flex; flex-direction:column; justify-content:center; align-items:center;
  color:white; font-family:Orbitron, Arial; font-size:24px;
  visibility:hidden; opacity:0; transition:opacity 0.5s;
}
#defeatOverlay.show { visibility:visible; opacity:1; }
#defeatOverlay h1 { color:red; font-size:40px; text-shadow:0 0 15px red; }
#defeatOverlay p { margin:10px 0; }
.defeatBtn {
  margin-top:20px; padding:12px 24px; font-size:20px;
  background:rgba(0,255,255,0.2); border:2px solid cyan; border-radius:10px;
  color:white; cursor:pointer;
  box-shadow:0 0 15px cyan;
}
.defeatBtn:hover { background:rgba(0,255,255,0.5); }

/* Upgrade Overlay */
#upgradeOverlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 20;
}
#upgradeOverlay.show { display: flex; }
#upgradeChoices {
  display: grid;
  gap: 1rem;
  margin-top: 1rem;
}
.upgradeBtn {
  background: #2563eb;
  color: white;
  padding: 12px 20px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 1.1rem;
  transition: transform .2s;
}
.upgradeBtn:hover { transform: scale(1.05); background:#1d4ed8; }

/* Mobile Controls */
#mobileControls {
  position: absolute;
  bottom: 30px;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
  align-items: center;
}

#btnShoot {
  font-size: 26px;
  width: 70px;
  height: 70px;
  border: none;
  border-radius: 50%;
  background: rgba(0, 255, 255, 0.25);
  color: white;
  box-shadow: 0 0 15px cyan inset, 0 0 10px cyan;
  transition: 0.1s;
}
#btnShoot:active { transform: scale(0.9); background: rgba(0,255,255,0.5); }

/* Joystick styling */
#joystickContainer {
  position: relative;
  width: 120px;
  height: 120px;
  touch-action: none;
}

#joystickBase {
  position: absolute;
  width: 100%;
  height: 100%;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  border: 2px solid cyan;
}

#joystickThumb {
  position: absolute;
  width: 50px;
  height: 50px;
  background: rgba(0,255,255,0.4);
  border-radius: 50%;
  top: 35px;
  left: 35px;
  touch-action: none;
}
</style>
</head>
<body>

<canvas id="spaceCanvas"></canvas>
<div id="scoreboard">Score: 0</div>
<div id="levelDisplay">Level: 1</div>
<div id="healthDisplay">Health: 5</div>
<a id="menuButton" href="games.html">Back to Menu</a>

<!-- Defeat Screen -->
<div id="defeatOverlay">
  <h1>GAME OVER</h1>
  <p id="finalScore">Score: 0</p>
  <p id="finalLevel">Level: 1</p>
  <button class="defeatBtn" onclick="restartGame()">Retry</button>
  <button class="defeatBtn" onclick="window.location.href='games.html'">Menu</button>
</div>

<!-- Upgrade Overlay -->
<div id="upgradeOverlay" class="overlay">
  <div class="overlay-content" style="background:#11182a; padding:22px; border-radius:12px; text-align:center; max-width:420px; width:90%;">
    <h2 style="color:white; margin-bottom:12px;">Choose an Upgrade</h2>
    <div id="upgradeChoices"></div>
  </div>
</div>

<!-- Mobile Controls: Joystick + Shoot -->
<div id="mobileControls">
  <div id="joystickContainer">
    <div id="joystickBase"></div>
    <div id="joystickThumb"></div>
  </div>
  <button id="btnShoot">ðŸ”¥</button>
</div>

<script>
/* =================== Canvas & Context =================== */
const canvas = document.getElementById('spaceCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

/* =================== Game state =================== */
let score = 0, level = 1, playerHealth = 5;
let bullets = [], enemies = [], activeCompanions = [];
let keys = {}, isGameOver = false, isPaused = false;

/* =================== Player upgrades =================== */
let playerBulletDamage = 1;   // "+1 Damage"
let playerBulletCount = 1;    // "+1 Bullet"
let fireRateMs = 400;         // "-Cooldown"
let lastShot = 0;

/* =================== Time / RAF =================== */
let running = false, rafId = null, lastTimestamp = 0;
const FRAME_MS = 1000 / 60;

/* =================== Entities =================== */
class Player {
  constructor(x,y,name='',isComp=false){
    this.x = x; this.y = y;
    this.width = 20; this.height = 20;
    this.color = isComp ? 'lime' : '#00ffff';
    this.speed = isComp ? 6 * 60 : 10 * 60; // px/sec
    this.isCompanion = isComp;
    this.name = name;
    this.lastFire = 0;
    this.fireIntervalMs = 20 * FRAME_MS;
    this.cooldown = 0;
  }
  draw(){
    ctx.shadowBlur = 15; ctx.shadowColor = this.color;
    ctx.beginPath(); ctx.moveTo(this.x,this.y);
    ctx.lineTo(this.x - this.width/2, this.y + this.height);
    ctx.lineTo(this.x + this.width/2, this.y + this.height);
    ctx.closePath(); ctx.fillStyle = this.color; ctx.fill();
    ctx.shadowBlur = 0;
    if (this.name) {
      ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
      ctx.fillText(this.name, this.x, this.y - 8);
    }
  }
  update(delta){
    if (this.isCompanion) {
      const visibleEnemies = enemies.filter(e => !e.targetedBy || e.targetedBy === this);
      const target = visibleEnemies.length > 0 ? visibleEnemies.sort((a,b) => b.y - a.y)[0] : null;
      enemies.forEach(e => { if (e.targetedBy === this && e !== target) e.targetedBy = null; });
      if (target) {
        target.targetedBy = this;
        const dx = target.x - this.x;
        const move = Math.sign(dx) * Math.min(Math.abs(dx), this.speed * delta);
        this.x += move;
        const now = performance.now();
        if (Math.abs(this.x - target.x) < 6 && now - this.lastFire >= this.fireIntervalMs) {
          bullets.push(new Bullet(this.x, this.y - 20, target, 1));
          this.lastFire = now;
        }
      }
    } else {
      updatePlayerFromJoystick(delta);
      updatePlayerFromKeyboard(delta);
    }
  }
}

class Bullet {
  constructor(x,y,target=null,damage=1){
    this.x = x; this.y = y;
    this.radius = 5;
    this.target = target;
    this.damage = damage || 1;
    this.speed = 10 * 60;
    this.color = 'cyan';
  }
  draw(){
    ctx.shadowBlur = 15; ctx.shadowColor = this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 0;
  }
  update(delta){
    if (this.target && enemies.includes(this.target)) {
      const dx = (this.target.x + this.target.size/2) - this.x;
      const dy = (this.target.y + this.target.size/2) - this.y;
      const angle = Math.atan2(dy, dx);
      this.x += Math.cos(angle) * this.speed * delta;
      this.y += Math.sin(angle) * this.speed * delta;
    } else { this.y -= this.speed * delta; }
  }
}

class Enemy {
  constructor(isBoss=false){
    this.size = isBoss ? 80 : 25;
    this.x = Math.random() * (canvas.width - this.size);
    this.y = -this.size - 50;
    this.speed = (isBoss ? 2 : 3) * 60;
    this.health = isBoss ? 15 : 2;
    this.targetedBy = null;
    this.isBoss = isBoss;
    this.color = isBoss ? 'orange' : `hsl(${Math.random()*360},100%,50%)`;
  }
  draw(){ ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
  update(delta){ this.y += this.speed * delta; }
}

/* =================== Setup Entities =================== */
const player = new Player(canvas.width/2, canvas.height - 150);
const companions = [
  new Player(canvas.width/2+120,canvas.height-190,'Lucky',true),
  new Player(canvas.width/2-120,canvas.height-190,'Mc. Melan',true),
  new Player(canvas.width/2+160,canvas.height-230,'George',true),
  new Player(canvas.width/2-160,canvas.height-230,'Frank',true),
  new Player(canvas.width/2-200,canvas.height-270,'Jule',true),
  new Player(canvas.width/2+200,canvas.height-270,'Jeff',true)
];
activeCompanions.push(...companions);

/* =================== MG & SPG =================== */
class MG {
  constructor(x,y,isHeavy=false){
    this.x = x; this.y = y;
    this.width = 40; this.height = 20;
    this.color = isHeavy ? 'darkred' : 'darkgreen';
    this.lastFire = 0;
    this.fireIntervalMs = isHeavy ? Math.round(8*FRAME_MS) : Math.round(20*FRAME_MS);
    this.angle = 0;
  }
  draw(){
    ctx.fillStyle = this.color; ctx.fillRect(this.x-this.width/2,this.y,this.width,this.height);
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    ctx.fillStyle = 'black'; ctx.fillRect(-4,-20,8,20); ctx.restore();
  }
  update(delta){
    let closest=null,minDist=Infinity;
    enemies.forEach(e=>{
      const dx=(e.x+e.size/2)-this.x;
      const dy=(e.y+e.size/2)-this.y;
      const d=Math.hypot(dx,dy);
      if(d<minDist){ minDist=d; closest=e; }
    });
    if(closest){ 
      this.angle=Math.atan2(closest.y-this.y,closest.x-this.x);
      const now=performance.now();
      if(now-this.lastFire>=this.fireIntervalMs){
        bullets.push(new Bullet(this.x,this.y,closest,1));
        this.lastFire=now;
      }
    }
  }
}

class SPG {
  constructor(){
    this.x=canvas.width/2; this.y=canvas.height-35;
    this.width=70; this.height=30; this.color='darkgray';
    this.lastFire=0;
    this.fireIntervalMs=Math.max(16,Math.round(1*FRAME_MS));
    this.angle=0;
  }
  draw(){
    ctx.fillStyle=this.color; ctx.fillRect(this.x-this.width/2,this.y,this.width,this.height);
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    ctx.fillStyle='darkred'; ctx.fillRect(-5,-this.height/2-30,10,30); ctx.restore();
  }
  update(delta){
    let closest=null,minDist=Infinity;
    enemies.forEach(e=>{
      const dx=(e.x+e.size/2)-this.x;
      const dy=(e.y+e.size/2)-this.y;
      const d=Math.hypot(dx,dy);
      if(d<minDist){ minDist=d; closest=e; }
    });
    if(closest){
      this.angle=Math.atan2((closest.y+closest.size/2)-this.y,(closest.x+closest.size/2)-this.x)-Math.PI/2;
      const now=performance.now();
      if(now-this.lastFire>=this.fireIntervalMs){
        bullets.push(new Bullet(this.x,this.y,closest,1));
        this.lastFire=now;
      }
    }
  }
}

const mgLeft = new MG(canvas.width/2-100,canvas.height-60,true);
const mgRight = new MG(canvas.width/2+100,canvas.height-60,true);
const spg = new SPG();

/* =================== Shooting =================== */
function shoot(){
  if(isGameOver||isPaused) return;
  const now=performance.now();
  if(now-lastShot<fireRateMs) return;
  lastShot=now;
  const y=player.y-20;
  const spread=10;
  for(let i=0;i<playerBulletCount;i++){
    const offset=(i-(playerBulletCount-1)/2)*spread;
    bullets.push(new Bullet(player.x+offset,y,null,playerBulletDamage));
  }
}

/* =================== Enemy Spawn =================== */
function spawnEnemy(){
  if(!isGameOver&&!isPaused){
    const count=1+Math.floor(level/2);
    for(let i=0;i<count;i++) enemies.push(new Enemy());
    if(level%5===0) enemies.push(new Enemy(true));
  }
}
setInterval(spawnEnemy,1500);

/* =================== HUD =================== */
function updateScoreboard(){ document.getElementById('scoreboard').textContent=`Score: ${score}`; }
function updateLevelDisplay(){ document.getElementById('levelDisplay').textContent=`Level: ${level}`; }
function updateHealthDisplay(){ document.getElementById('healthDisplay').textContent=`Health: ${playerHealth}`; }

/* =================== Controls =================== */
document.getElementById('btnShoot').addEventListener('pointerdown',shoot);

/* =================== Keyboard Controls =================== */
keys={up:false,down:false,left:false,right:false};
window.addEventListener('keydown',e=>{
  if(['ArrowUp','KeyW'].includes(e.code)) keys.up=true;
  if(['ArrowDown','KeyS'].includes(e.code)) keys.down=true;
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=true;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=true;
  if(e.code==='Space') shoot();
});
window.addEventListener('keyup',e=>{
  if(['ArrowUp','KeyW'].includes(e.code)) keys.up=false;
  if(['ArrowDown','KeyS'].includes(e.code)) keys.down=false;
  if(['ArrowLeft','KeyA'].includes(e.code)) keys.left=false;
  if(['ArrowRight','KeyD'].includes(e.code)) keys.right=false;
});

/* =================== Update from keyboard =================== */
function updatePlayerFromKeyboard(delta){
  let dx=0,dy=0;
  if(keys.left) dx-=1; if(keys.right) dx+=1;
  if(keys.up) dy-=1; if(keys.down) dy+=1;
  const mag=Math.hypot(dx,dy);
  if(mag>0){ dx/=mag; dy/=mag; player.x+=dx*player.speed*delta; player.y+=dy*player.speed*delta; }
  player.x=Math.max(0,Math.min(canvas.width,player.x));
  player.y=Math.max(0,Math.min(canvas.height,player.y));
}

/* =================== JOYSTICK =================== */
let joystickActive=false;
let joystickX=0,joystickY=0;
const joystickThumb=document.getElementById('joystickThumb');
const joystickBase=document.getElementById('joystickBase');
const joystickRadius=50;

function clamp(val,min,max){ return Math.max(min,Math.min(max,val)); }

joystickThumb.addEventListener('pointerdown',e=>{ joystickActive=true; joystickThumb.setPointerCapture(e.pointerId); });
joystickThumb.addEventListener('pointermove',e=>{
  if(joystickActive){
    const rect=joystickBase.getBoundingClientRect();
    let x=e.clientX-(rect.left+rect.width/2);
    let y=e.clientY-(rect.top+rect.height/2);
    const dist=Math.hypot(x,y);
    if(dist>joystickRadius){ x=x/dist*joystickRadius; y=y/dist*joystickRadius; }
    joystickX=x/joystickRadius; joystickY=y/joystickRadius;
    joystickThumb.style.transform=`translate(${x}px,${y}px)`;
  }
});
joystickThumb.addEventListener('pointerup',e=>{
  joystickActive=false; joystickX=0; joystickY=0;
  joystickThumb.style.transform='translate(0px,0px)';
});

function updatePlayerFromJoystick(delta){
  if(Math.abs(joystickX)>0.05 || Math.abs(joystickY)>0.05){
    player.x+=joystickX*player.speed*delta;
    player.y+=joystickY*player.speed*delta;
    player.x=clamp(player.x,0,canvas.width);
    player.y=clamp(player.y,0,canvas.height);
  }
}

/* =================== Game Over =================== */
function gameOver(){
  isGameOver=true;
  document.getElementById('finalScore').textContent=`Score: ${score}`;
  document.getElementById('finalLevel').textContent=`Level: ${level}`;
  document.getElementById('defeatOverlay').classList.add('show');
}
function restartGame(){
  score=0; level=1; playerHealth=5; bullets=[]; enemies=[]; isGameOver=false;
  player.x=canvas.width/2; player.y=canvas.height-150;
  updateScoreboard(); updateLevelDisplay(); updateHealthDisplay();
  document.getElementById('defeatOverlay').classList.remove('show');
  startLoop();
}

/* =================== Resize =================== */
window.addEventListener('resize',()=>{
  const wRatio=window.innerWidth/canvas.width;
  const hRatio=window.innerHeight/canvas.height;
  player.x*=wRatio; player.y*=hRatio;
  activeCompanions.forEach(c=>{ c.x*=wRatio; c.y*=hRatio; });
  mgLeft.x*=wRatio; mgLeft.y*=hRatio;
  mgRight.x*=wRatio; mgRight.y*=hRatio;
  spg.x*=wRatio; spg.y*=hRatio;
  canvas.width=window.innerWidth; canvas.height=window.innerHeight;
});

/* =================== Game Loop =================== */
function update(delta){
  if(isGameOver||isPaused) return;
  player.update(delta);
  activeCompanions.forEach(c=>c.update(delta));
  bullets.forEach(b=>b.update(delta));
  enemies.forEach(e=>e.update(delta));
  mgLeft.update(delta); mgRight.update(delta); spg.update(delta);

  bullets=bullets.filter(b=>b.y>0&&b.y<canvas.height&&(b.target===null||enemies.includes(b.target)));
  enemies=enemies.filter(e=>{ 
    if(e.y>canvas.height){ playerHealth--; updateHealthDisplay(); if(playerHealth<=0) gameOver(); return false; }
    return true; 
  });

  bullets.forEach(b=>{
    enemies.forEach(e=>{
      if(e && Math.hypot(e.x+e.size/2-b.x,e.y+e.size/2-b.y)<b.radius+e.size/2){
        e.health-=b.damage; b.damage=0;
        if(e.health<=0){ enemies.splice(enemies.indexOf(e),1); score+=e.isBoss?10:1; updateScoreboard(); }
      }
    });
  });
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  player.draw();
  activeCompanions.forEach(c=>c.draw());
  bullets.forEach(b=>b.draw());
  enemies.forEach(e=>e.draw());
  mgLeft.draw(); mgRight.draw(); spg.draw();
}

function loop(timestamp){
  if(!running) return;
  const delta=(timestamp-lastTimestamp)/1000;
  lastTimestamp=timestamp;
  update(delta);
  draw();
  rafId=requestAnimationFrame(loop);
}
function startLoop(){ running=true; lastTimestamp=performance.now(); rafId=requestAnimationFrame(loop); }
function stopLoop(){ running=false; cancelAnimationFrame(rafId); }

startLoop();
</script>
</body>
</html>
