<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CliJo - Quantum Strike </title>
<link rel="icon" href="logo.png" type="image/png">
<style>
body { margin:0; overflow:hidden; background:black; touch-action:none; }
canvas { display:block; }
#scoreboard, #levelDisplay, #healthDisplay {
  position:absolute; color:cyan; font:20px Arial; top:10px;
}
#levelDisplay { left:10px; }
#scoreboard { right:10px; }
#healthDisplay { left:10px; top:40px; color:red; }
#mobileControls {
  position:absolute; bottom:30px; width:100%;
  display:flex; justify-content:space-between; padding:0 20px;
}
#mobileControls button {
  font-size:24px; width:60px; height:60px; margin:5px;
  border:none; border-radius:10px; background:rgba(0,255,255,0.3); color:white;
}
#menuButton {
  position:absolute; top:70px; left:10px; font-size:18px; padding:5px 10px;
  background:rgba(255,0,0,0.5); color:white; border:none; border-radius:5px;
}
</style>
</head>
<body>

<canvas id="spaceCanvas"></canvas>
<div id="scoreboard">Score: 0</div>
<div id="levelDisplay">Level: 1</div>
<div id="healthDisplay">Health: 5</div>
<a id="menuButton" href="games.html">Back to Menu</a>

<div id="mobileControls">
  <div>
    <button id="btnLeft">â—€</button>
    <button id="btnRight">â–¶</button>
    <button id="btnUp">â–²</button>
    <button id="btnDown">â–¼</button>
  </div>
  <button id="btnShoot">ðŸ”¥</button>
</div>

<script>
const canvas = document.getElementById('spaceCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let score=0, level=1, playerHealth=5;
let bullets=[], enemies=[], activeCompanions=[];
let keys={}, isGameOver=false;

class Player {
  constructor(x,y,name='',isComp=false){
    this.x=x; this.y=y; this.width=20; this.height=20;
    this.color=isComp?'lime':'#00ffff'; this.speed=isComp?6:10;
    this.isCompanion=isComp; this.name=name; this.cooldown=0;
  }
  draw(){
    ctx.shadowBlur=15; ctx.shadowColor=this.color;
    ctx.beginPath(); ctx.moveTo(this.x,this.y);
    ctx.lineTo(this.x-this.width/2,this.y+this.height);
    ctx.lineTo(this.x+this.width/2,this.y+this.height);
    ctx.closePath(); ctx.fillStyle=this.color; ctx.fill();
    ctx.shadowBlur=0;
    if(this.name){ctx.fillStyle='white';ctx.font='12px Arial';ctx.textAlign='center';ctx.fillText(this.name,this.x,this.y-8);}
  }
  update(){
    if(this.isCompanion){
      const visibleEnemies=enemies.filter(e=>!e.targetedBy||e.targetedBy===this);
      let target=visibleEnemies.length>0?visibleEnemies.sort((a,b)=>b.y-a.y)[0]:null;
      enemies.forEach(e=>{if(e.targetedBy===this&&e!==target)e.targetedBy=null;});
      if(target){
        target.targetedBy=this;
        if(this.x<target.x-2)this.x+=this.speed; else if(this.x>target.x+2)this.x-=this.speed;
        if(Math.abs(this.x-target.x)<5&&this.cooldown<=0){bullets.push(new Bullet(this.x,this.y-20,target)); this.cooldown=20;} else this.cooldown--;
      }
    } else {
      if(keys['ArrowLeft']&&this.x-this.speed>0)this.x-=this.speed;
      if(keys['ArrowRight']&&this.x+this.speed<canvas.width)this.x+=this.speed;
      if(keys['ArrowUp']&&this.y-this.speed>0)this.y-=this.speed;
      if(keys['ArrowDown']&&this.y+this.speed<canvas.height)this.y+=this.speed;
    }
  }
}

class Bullet {
  constructor(x,y,target=null){this.x=x; this.y=y; this.radius=5; this.target=target; this.speed=10; this.color='cyan';}
  draw(){ctx.shadowBlur=15;ctx.shadowColor=this.color;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);ctx.fillStyle=this.color;ctx.fill();ctx.shadowBlur=0;}
  update(){
    if(this.target && enemies.includes(this.target)){
      const dx=(this.target.x+this.target.size/2)-this.x;
      const dy=(this.target.y+this.target.size/2)-this.y;
      const angle=Math.atan2(dy,dx);
      this.x+=Math.cos(angle)*this.speed;
      this.y+=Math.sin(angle)*this.speed;
    } else { this.y-=this.speed; }
  }
}

class Enemy {
  constructor(isBoss=false){this.size=isBoss?80:25; this.x=Math.random()*(canvas.width-this.size); this.y=-this.size-50;
  this.speed=isBoss?2:3; this.health=isBoss?15:2; this.targetedBy=null; this.isBoss=isBoss;
  this.color=isBoss?'orange':`hsl(${Math.random()*360},100%,50%)`;}
  draw(){ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,this.size,this.size);}
  update(){this.y+=this.speed;}
}

class MG {
  constructor(x,y,isHeavy=false){this.x=x; this.y=y; this.width=40; this.height=20; this.color=isHeavy?'darkred':'darkgreen'; this.cooldown=0; this.angle=0; this.isHeavy=isHeavy;}
  draw(){ctx.fillStyle=this.color; ctx.fillRect(this.x-this.width/2,this.y,this.width,this.height);
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle='black'; ctx.fillRect(-4,-20,8,20); ctx.restore();}
  update(){
    let closest=null,minDist=Infinity;
    enemies.forEach(e=>{
      const dx=(e.x+e.size/2)-this.x; const dy=(e.y+e.size/2)-this.y;
      const d=Math.sqrt(dx*dx+dy*dy); if(d<minDist){minDist=d; closest=e;}
    });
    if(closest){
      this.angle=Math.atan2(closest.y-this.y,closest.x-this.x);
      if(this.cooldown<=0){
        bullets.push(new Bullet(this.x,this.y,closest));
        this.cooldown=this.isHeavy?8:20;
      } else this.cooldown--;
    }
  }
}

class SPG{
  constructor(){this.x=canvas.width/2; this.y=canvas.height-35; this.width=70; this.height=30; this.color='darkgray'; this.cooldown=0; this.angle=0;}
  draw(){ctx.fillStyle=this.color; ctx.fillRect(this.x-this.width/2,this.y,this.width,this.height);
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle='darkred'; ctx.fillRect(-5,-this.height/2-30,10,30); ctx.restore();}
  update(){
    let closest=null,minDist=Infinity;
    enemies.forEach(e=>{
      const dx=(e.x+e.size/2)-this.x; const dy=(e.y+e.size/2)-this.y;
      const d=Math.sqrt(dx*dx+dy*dy); if(d<minDist){minDist=d; closest=e;}
    });
    if(closest){
      this.angle=Math.atan2((closest.y+closest.size/2)-this.y,(closest.x+closest.size/2)-this.x)-Math.PI/2;
      if(this.cooldown<=0){
        bullets.push(new Bullet(this.x,this.y,closest));
        this.cooldown=1;
      } else this.cooldown--;
    }
  }
}

const player=new Player(canvas.width/2,canvas.height-150);
const companions=[
  new Player(canvas.width/2+120,canvas.height-190,'Lucky',true),
  new Player(canvas.width/2-120,canvas.height-190,'Mc. Melan',true),
  new Player(canvas.width/2+160,canvas.height-230,'George',true),
  new Player(canvas.width/2-160,canvas.height-230,'Frank',true),
  new Player(canvas.width/2-200,canvas.height-270,'Jule',true),
  new Player(canvas.width/2+200,canvas.height-270,'Jeff',true)
];
activeCompanions.push(...companions);

const mgLeft=new MG(canvas.width/2-100,canvas.height-60,true);
const mgRight=new MG(canvas.width/2+100,canvas.height-60,true);
const spg=new SPG();

function shoot(){ bullets.push(new Bullet(player.x,player.y-20)); }
function spawnEnemy(){ const count=1+Math.floor(level/2); for(let i=0;i<count;i++) enemies.push(new Enemy()); if(level%5===0) enemies.push(new Enemy(true)); }
setInterval(spawnEnemy,1500);

function updateScoreboard(){document.getElementById('scoreboard').textContent=`Score: ${score}`;}
function updateLevelDisplay(){document.getElementById('levelDisplay').textContent=`Level: ${level}`;}
function updateHealthDisplay(){document.getElementById('healthDisplay').textContent=`Health: ${playerHealth}`;}

const btnLeft=document.getElementById('btnLeft'),btnRight=document.getElementById('btnRight');
const btnUp=document.getElementById('btnUp'),btnDown=document.getElementById('btnDown'),btnShoot=document.getElementById('btnShoot');
btnLeft.onpointerdown=()=>keys['ArrowLeft']=true;btnLeft.onpointerup=()=>keys['ArrowLeft']=false;
btnRight.onpointerdown=()=>keys['ArrowRight']=true;btnRight.onpointerup=()=>keys['ArrowRight']=false;
btnUp.onpointerdown=()=>keys['ArrowUp']=true;btnUp.onpointerup=()=>keys['ArrowUp']=false;
btnDown.onpointerdown=()=>keys['ArrowDown']=true;btnDown.onpointerup=()=>keys['ArrowDown']=false;
btnShoot.onclick=shoot;
document.getElementById('menuButton').onclick=()=>{window.location.href='game.html';};

window.addEventListener('keydown',e=>keys[e.key]=true);
window.addEventListener('keyup',e=>{ keys[e.key]=false; if(e.key===' ') shoot(); });

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  player.update(); player.draw();
  activeCompanions.forEach(c=>{c.update(); c.draw();});
  spg.update(); spg.draw();
  mgLeft.update(); mgLeft.draw(); mgRight.update(); mgRight.draw();
  bullets.forEach((b,i)=>{
    b.update(); b.draw();
    if(b.y<0||b.y>canvas.height||b.x<0||b.x>canvas.width) bullets.splice(i,1);
  });
  enemies.forEach((e,i)=>{
    e.update(); e.draw();
    bullets.forEach((b,bi)=>{
      const dx=b.x-(e.x+e.size/2); const dy=b.y-(e.y+e.size/2);
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<b.radius+e.size/2){
        e.health--;
        bullets.splice(bi,1);
        if(e.health<=0){enemies.splice(i,1); score+=e.isBoss?100:10; updateScoreboard(); if(score%100===0){level++; updateLevelDisplay();} }
      }
    });
    if(e.y>canvas.height){playerHealth--; updateHealthDisplay(); enemies.splice(i,1);}
  });
  if(playerHealth<=0){isGameOver=true; alert('Defeated! Returning to menu.'); window.location.href='games.html';}
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
